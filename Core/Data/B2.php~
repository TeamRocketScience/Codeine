<?php

/*
 * Unified Memory Architecture
 * B2 Implementation
 */

class VXData // UMA
{
    
    private static $_Mounts;
    private static $_Storages;
    
    private static $_Mounted;
    private static $_Connected;

    private static $_MST;       // Mount - Storage Table

    private static $_Data;
    public  static $Cache;
    private static $_Transactions;

    public static function GetMounted ($Index = null)
    {
        if (null === $Index)
            return self::$_Points;
        else
            return self::$_Points[$Index];
    }

    public static function GetORM ($Point = null)
    {
        if ($Point)
        {
            self::Mount($Point);

            if (null === $Point)
                return self::$_ORMs;
            else
            {
                if (isset(self::$_MST[$Point]) and isset(self::$_Storages[self::$_MST[$Point]]))
                    return self::$_Storages[self::$_MST[$Point]]['ORM'];
                else
                    return null;
            }
        }
        else
            return null;
    }

    private static function _Connect ($Name)
    {
        VXTiming::Go ('Сonnecting to '.$Name);
        $Returned = null;
        VXLogger::Important($Name);

        if (($Name != 'Static') and isset(self::$_Storages[$Name]))
        {
            if (!isset(self::$_Connected[$Name]))
            {
                $Connected = VXCode::E('Data/Mounters','Mount', self::$_Storages[$Name], self::$_Storages[$Name]['Method']);

                if ($Connected !== null)
                {
                    self::$_Connected[$Name] = $Connected;
                    $Returned = true;
                    VXLogger::Good('VXData: Подключение к '.$Name.' успешно.', 'VXD');
                }
                else
                    VXLogger::Error('VXData: Подключение к '.$Name.' не удалось.', 'VXD');
            }
            else
                if (self::$_Connected[$Name] !== null)
                    $Returned = true;
        }
            else
                $Returned = true;
        
        VXTiming::Stop ('Сonnecting to '.$Name);
        return $Returned;
    }

    public static function Mount ($Point)
    {
        VXTiming::Go ('Mounting '.$Point);
        
        $Result = null;

        if (isset(self::$_Mounts[$Point]))
        {
            if (!isset(self::$_Mounted[$Point]) and !empty($Point))
            {
                $StorageID = self::$_Mounts[$Point]['Node'];
                // FIXME: Not once Storage

                if (null !== self::_Connect($StorageID))
                    self::$_MST[$Point] = $StorageID;
                else
                    $Result = null;
            }
            else
                $Result = true;
        }
        else
            $Result = null;

        VXTiming::Stop('Mounting '.$Point);

        return $Result;
    }

    public static function Unmount($Point)
    {           
        VXTiming::Go ('Unmounting '.$Point);

        $Name = self::$_MST[$Point];
        if (isset(self::$_Storages[$Name]))
            $Result = VXCode::E('Data/Mounters','Unmount', self::$_Connected[$Name], self::$_Storages[$Name]['Method']);
        else
            $Result = true;
        
        VXTiming::Stop('Unmounting '.$Point);

        return $Result;
    }

    public static function Initialize ()
    {
        VXTiming::Go('VXData:Initialize');

            self::$_Storages = json_decode(file_get_contents (Root.'Storage.json')  , true);
            self::$_Mounts   = json_decode(file_get_contents (Root.'Mount.json')    , true);
        
        VXTiming::Stop('VXData:Initialize');
      
        return true;
    }

    public static function _UnmountAll()
    {
        while(list($Point,$Storage) = each(self::$_MST))
            self::Unmount($Point);
        return true;
    }

    private static function CRUD ($Method, $Point, $DDL)
    {
        VXTiming::Go ('VXData '.$Point.':*');
        VXTiming::Go ('VXData *:'.$Method);
        VXTiming::Go ('VXData '.$Point.':'.$Method);
        
        $Result = null;
        
        self::Mount ($Point);
        
        $Storage    = &self::$_Storages[self::$_MST[$Point]];
        $Connected  = &self::$_Connected[self::$_MST[$Point]];
        $Mount      = &self::$_Mounts[$Point];

        if (is_string($DDL))
        {
            if (null === ($DDL2 = json_decode($DDL, true)))
                return VXLogger::Error('VXData: В JSON вызове обнаружена ошибка.'.$DDL);
            else
                $DDL = $DDL2;
        }
        elseif (!is_array($DDL))
            return VXLogger::Error('VXData: Неверный формат вызова.'.$DDL);

        if (isset($Storage['Processor']))
            $DDL = VXCode::E('Data/Processors', $Method.'_Pre', $DDL, $Storage['Processor']);

        $Result
            = VXCode::E('Data/Mounters', 
                        $Method,
                        array(
                            'DDL'    => $DDL,
                            'Dir'   => $Mount['Dir'],
                            'Storage' => $Connected,
                            ), $Storage['Method']);

        if (isset($Storage['Processor']))
            $DDL = VXCode::E('Data/Processors', $Method.'_Post', $DDL, $Storage['Processor']);

        VXLogger::Tap('VXData:'.$Method);
        VXLogger::Tap('VXData:'.$Point);
        VXLogger::Tap('VXData:All');
        
        VXTiming::Stop ('VXData '.$Point.':*');
        VXTiming::Stop ('VXData *:'.$Method);
        VXTiming::Stop ('VXData '.$Point.':'.$Method);

        return $Result;
    }

    public static function Create($Point, $DDL)  // Create
    {       
        return self::CRUD ('Create', $Point, $DDL);
    }

    public static function Read($Point, $DDL, $EnableCache = true)    // Read
    {       
        if ($EnableCache)
            {
                $VXDRID = 'R'.$Point.md5($DDL);

                if (isset(self::$_Mounts[$Point]['ReadCache']))
                {
                    if (($Data = self::CacheGet(self::$_Mounts[$Point]['ReadCache'], $VXDRID)) == null)
                    {
                        $Data = self::CRUD ('Read', $Point, $DDL);
                        self::CachePut(self::$_Mounts[$Point]['ReadCache'], $VXDRID, $Data);
                        VXLogger::Tap('VXData:Cache:Read:Miss');
                    }
                    else
                        VXLogger::Tap('VXData:Cache:Read:Hit');
                }
                else
                {
                    if (isset(self::$_Cache[$VXDRID]))
                        {
                            $Data = self::$_Cache[$VXDRID];
                            VXLogger::Tap('VXData:Cache:Read:Hit');
                        }
                    else
                        {
                            $Data = self::CRUD ('Read', $Point, $DDL);
                            self::$_Cache[$VXDRID] = $Data;
                            VXLogger::Tap('VXData:Cache:Read:Miss');
                        }
                }

                return $Data;
            }
        else
            return self::CRUD ('Read', $Point, $DDL);
    }

    public static function Update ($Point, $DDL) // Update
    {
        if (isset(self::$_Storages[self::$_MST[$Point]]['transaction']))
            self::$_Transactions[$Point][] = array($DDL, 'Update');
        else
            return self::CRUD ('Update', $Point, $DDL);
    }

    public static function Delete ($Point, $DDL) // Delete
    {
        return self::CRUD ('Delete', $Point, $DDL);
    }

    public static function Exist ($Point, $DDL, $EnableCache = true) // Exist
    {
        if ($EnableCache)
            {
                $VXDRID = 'E:'.$Point.md5($DDL);

                if (!isset (self::$_Data[$VXDRID]))
                {
                    VXLogger::Tap('VXData:Cache:Exist:Miss');
                    self::$_Data[$VXDRID] = self::CRUD ('Exist', $Point, $DDL);
                }
                else
                    VXLogger::Tap('VXData:Cache:Exist:Hit');

                return self::$_Data[$VXDRID];
            }
        else
            return self::CRUD ('Exist', $Point, $DDL);
    }

    public static function Start ($Point)
    {
        self::$_Transactions[$Point] = array();
        return true;
    }

    public static function Commit ($Point)
    {
        $DDL = null;
        
        if (!empty(self::$_Transactions[$Point]))
        {
            VXLogger::Info('Commit '.$Point);
            $CLog = self::$_Transactions[$Point];
            
            if (!empty($CLog))
                {
                reset();
                while(list(,$cLog) = each($CRUD))
                    {
                        list ($DDL, $Method) = $CRUD;
                        self::CRUD($Point, $DDL, $Method);
                    }
                self::$_Transactions[$Point] = array();
                }
        }
        return true;
    }
    
    public static function Rollback ($Point = null)
    {
        if (null !== $Point)
            self::$_Transactions[$Point] = array();
        else
            self::$_Transactions = array();
        return true;
    }

    // Методы кеширования

    public static function CachePut ($Point, $ID, $Value, $TTL = 3600)
    {
        VXLogger::Tap('VXData:Cache:Put');
        if ($Point == 'Static')
            return (self::$_Data[$ID] = $Value);
        else
            return self::CRUD('Create', $Point,
                '{"I":"'.$ID.'","Value":'.json_encode(array('Expire'=>(time()+$TTL),
                                            'Data'=>$Value)).'}');
    }

    public static function CacheGet ($Point, $ID, $Or = null)
    {
        if ($Point == 'Static')
        {
            if (isset(self::$_Data[$ID]))
                return self::$_Data[$ID];
            else
                return null;
        }
        
        $Result = self::CRUD('Read', $Point, '{"I":"'.$ID.'"}');

        if ($Result !== null)
            return $Result['Value']['Data'];
        else
            VXLogger::Tap('VXData:Cache:Get:Miss');

        return $Or;
    }

    public static function CacheDel($Point, $ID)
    {
        return self::Delete($Point, '{"I":"'.$ID.'"}');
    }


    // Методы пула

    public static function PoolPut ($ID, $Value)
    {
        VXLogger::Tap('VXData:Pool:Put');
        self::$_Data['Pool'.$ID] = $Value;
        return true;
    }

    public static function PoolGet ($ID)
    {
        if (isset(self::$_Data['Pool'.$ID]))
        {
            VXLogger::Tap('VXData:Pool:Get:Hit');
            return self::$_Data['Pool'.$ID];
        }
        else
        {
            VXLogger::Tap('VXData:Pool:Get:Miss');
            return null;
        }
    }

    public static function Shutdown()
    {
        self::_UnmountAll();
    }
}
